<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <style>
  body {
  margin:40px auto;
  line-height:1.6;
  font-size:18px;
  color:#333;
  background:#f1f1f1;
  padding:0 10px
  }
  .description, h1, h2, h3 {
  max-width:800px;
  }
  h1,h2,h3 {
  line-height: 1.2
  }
  .mermaid {
  max-width: 1500px;
  }
  .collapsible {
  background-color: #777;
  color: white;
  cursor: pointer;
  padding: 5px;
  border: 2px transparent;
  text-align: left;
  outline: none;
  }
  .active, .collapsible:hover {
  background-color: #333;
  }
  .content {
  padding: 0 18px;
  display: none;
  overflow: hidden;
  background-color: #e1e1e1;
  }
  </style>
</head>
<body>
  <h1>Node in the Network</h1>

  <h2>Node's entire lifetime</h2>
  <div class=description>
  <p>This section describes the flow a node will follow during its entire lifetime.<br/>
  When they join the network, they won't yet be a member of any section.<br/>
  First,they will have to bootstrap with their proxy node, receive a RelocateInfo and attempt to join the section that this RelocateInfo is pointing to.<br/>
  Once they have a full section, they will be able to operate as a full section member.
  </p>
  <button class="collapsible">OWN_SECTION</button>
  <div class="content">
      <p> OWN_SECTION refers to this node's own section.<br/>
      It is an Option&ltPrefix&gt.<br/>
      While a node is being relocated, the value will be none. Once they get accepted into a section, it becomes Some(that_section_s_prefix)
  </p>
  </div>
  <button class="collapsible">BootstrapAndRelocate</button>
  <div class="content">
      <p>This function gets called when a node just joined the Network.<br/>
      At this stage, we are connected to a proxy node and they indicate to us which section we should join.
      </p>
  </div>
  <button class="collapsible">StartTopMember</button>
  <div class="content">
      <p>Once a node has joined a section (indicated by OWN_SECTION.is_some()), they will be able to perform as a member of that section until they are relocated away from it.<br/>
      See StartTopMember graph for details.
      </p>
  </div>
  <button class="collapsible">Rebootstrap</button>
  <div class="content">
      <p>First Create new identity with public key-pair<br/>
      The node connects to a proxy with the new identity to use for joining the new section as a full node.
      </p>
  </div>
  <button class="collapsible">JoiningRelocateCandidate</button>
  <div class="content">
      <p>Once a node knows where to be relocated, they will follow this flow to become a full member of the section.<br/>
      This covers resource proof from the point of view of the node being resource-proofed.<br/>
      The output of this function is an Option. If we fail resource proof, it is none, which means we will have to bootstrap again. If it is Some, it contains the RelocateInfo we need to join this section.<br/>
    See JoiningRelocateCandidate graph for details.
      </p>
  </div>
  </div>
  <div class="mermaid">
    graph TB

    Start --> LoopStart
    style Start fill:#f9f,stroke:#333,stroke-width:4px

    LoopStart --> HasSection
    HasSection(("Check?"))

    HasSection --"OWN_SECTION.is_none()"--> BootstrapAndRelocate
    BootstrapAndRelocate["BootstrapAndRelocate:<br/>Get RelocateInfo"]
    BootstrapAndRelocate --> ReBootstrapWithNewIdentity

    HasSection --"OWN_SECTION.is_some()"--> StartTopMember
    StartTopMember["StartTopMember<br/>"]
    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    StartTopMember --> ReBootstrapWithNewIdentity

    ReBootstrapWithNewIdentity["Rebootstrap<br/>with new relocated identity<br/>output: RelocateInfo"]
    style ReBootstrapWithNewIdentity fill:#f9f,stroke:#333,stroke-width:4px
    ReBootstrapWithNewIdentity --> JoiningRelocateCandidate

    JoiningRelocateCandidate["JoiningRelocateCandidate(RelocateInfo)<br/>output: JoiningApproved"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px

    SetNodeApproaval["OWN_SECTION=JoiningApproved"]
    JoiningRelocateCandidate --> SetNodeApproaval

    SetNodeApproaval --> LoopEnd
    LoopEnd --> LoopStart
  </div>

  <h2>Becoming a full member of a section</h2>
  <div class=description>
  This is from the point of view of a node trying to join a section as a full member.<br/>
  This node is going to try to be accepted as candidate until it receives a NodeConnected RPC to complete this stage successfully.<br/>
  This node is going to perform the resource proof until it receives a NodeApproval RPC to complete this stage successfully.<br/>
  If the node is not accepted, after time out, it will try another section.
  </div>
  <div class="mermaid">
    graph TB
    JoiningRelocateCandidate -->  InitialSendConnectionInfoRequest
    JoiningRelocateCandidate["JoiningRelocateCandidate<br/>(Take destination section nodes)"]
    style JoiningRelocateCandidate fill:#f9f,stroke:#333,stroke-width:4px
    EndRoutine["End of JoiningRelocateCandidate<br/>"]
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

    InitialSendConnectionInfoRequest["send_rpc(CandidateInfo) to target NaeManger<br/><br/>schedule(TimeoutResendInfo)<br/>schedule(TimeoutRefused)"]
    InitialSendConnectionInfoRequest-->LoopStart

    LoopStart --> WaitFor
    WaitFor(("Wait for 6:"))
    LocalEvent((Local<br/>Event))
    WaitFor --> LocalEvent

    LocalEvent -- ResourceProofForElderReady -->  SendFirstResourceProofPartForElder
    SendFirstResourceProofPartForElder["send_rpc(<br/>ResourceProofResponse)<br/>with first part for elder"]
    SendFirstResourceProofPartForElder --> LoopEnd

    LocalEvent--"TimeoutResendInfo triggered<br/>CONNECTED==false"--> ResendCandidateInfo
    ResendCandidateInfo["send_rpc(CandidateInfo)<br/><br/>schedule(TimeoutResendInfo)"]
    ResendCandidateInfo --> LoopEnd

    LocalEvent--"TimeoutRefused<br/>triggered"--> EndRoutine

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- NodeApproval -->  EndRoutine

    Rpc -- NodeConnected --> NodeConnected
    NodeConnected["CONNECTED=true<br/><br/>kill_scheduled(TimeoutRefused)"]
    NodeConnected-->LoopEnd

    Rpc -- ConnectionInfoRequest --> OnConnectionInfoRequest
    OnConnectionInfoRequest["send_rpc(<br/>ConnectionInfoResponse)"]
    OnConnectionInfoRequest-->LoopEnd

    Rpc -- ResourceProofReceipt -->  SendNextResourceProofPartForElder
    SendNextResourceProofPartForElder["send_rpc(<br/>ResourceProofResponse)<br/>part for elder"]
    SendNextResourceProofPartForElder --> LoopEnd

    Rpc -- ResourceProof -->  StartComputeResourceProofForElder
    StartComputeResourceProofForElder["start_compute_resource_proof(source elder)<br/><br/>schedule(TimeoutRefused)"]
    StartComputeResourceProofForElder --> LoopEnd

    Rpc -- "ExpectCandidate<br/>RefuseCandidate<br/>RelocateResponse<br/>..." --> VoteParsecRPC
    VoteParsecRPC["vote_for(the parsec rpc)<br/>(cache for later)"]
    VoteParsecRPC --> LoopEnd

    LoopEnd --> LoopStart

  </div>

  <h2>Node as a member of a section</h2>
  <div class=description>
  <p>Once a node has joined a section, they need to be ready to take on multiple roles simultaneously:<br/>
  <ul>
    <li> Deal with relocation:<br/>
         The section as a whole will sometimes act as the source and sometimes as the destination of relocations. This means nodes will sometimes relocate away from this section and sometimes relocate to this section. Nodes in this section will need to perform the right flow to deal with both of these situations.
    <li> Decide who's an elder or a plain old adult as well as when to merge
    <li> Decide who is online and offline
  </ul>
  All of these flows are happening simultaneously, but they share a common event loop. At any time, either all flows or all but one flows  must be in a "wait" state.<br/>
  If our section decides to relocates us, we will have to stop functioning as a member of our section and go back to the previous flow where we will "Rebootstrap" so we can become a member of a different section.
  </p>
  </div>
  <div class="mermaid">
    graph TB
    style StartTopMember fill:#f9f,stroke:#333,stroke-width:4px
    style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px
    StartTopMember --> InitializeNodeInternalState
    InitializeNodeInternalState["intialise_node_internal_state()<br/><br/>(Parsed, Routing table...)"]
    InitializeNodeInternalState --> ConcurentStartElder

    ConcurentStartElder{"Concurrent<br/>start elder"}

    ConcurentStartElder --> ConcurentStartSrc
    ConcurentStartSrc{"Concurrent<br/>start src"}

    ConcurentStartSrc --> StartTopLevelSrc
    style StartTopLevelSrc fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartSrc --> StartRelocateSrc
    style StartRelocateSrc fill:#f9f,stroke:#333,stroke-width:4px


    ConcurentStartElder --> ConcurentStartDst
    ConcurentStartDst{"Concurrent<br/>start dst"}

    ConcurentStartDst --> StartTopLevelDst
    style StartTopLevelDst fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartDst --> StartRelocatedNodeConnection
    StartRelocatedNodeConnection[StartRelocatedNodeConnection]
    style StartRelocatedNodeConnection fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartDst --> StartResourceProof
    StartResourceProof[StartResourceProof]
    style StartResourceProof fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> StartCheckAndProcessElderMergeChange
    style StartCheckAndProcessElderMergeChange fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> CheckOnlineOffline
    style CheckOnlineOffline fill:#f9f,stroke:#333,stroke-width:4px

    ConcurentStartElder --> WaitFor

    WaitFor(("Wait for 0:"))

    Rpc((RPC))
    WaitFor --> Rpc
    Rpc -- "RelocatedInfo RPC"-->  EndRoutine
    EndRoutine["EndRoutine: Kill all sub routines"]
</div>

  <h1>Destination section</h1>
  <div class=description>
  <p>As a member of a section, our section will sometimes receive a node that is being relocated. These  diagrams are from the point of view of one of the nodes in the section, doing its part to handle the node that is trying to relocate to this section.
  </p>
  </div>
  <h2>Deciding when to accept an incoming relocation</h2>
  <div class=description>
  <p>This flow represents what we do when a section contacts us to relocate one of their nodes to our section.<br/>
  The process starts as we receive an ExpectCandidate RPC from this node.<br/>
  We vote for it in PARSEC to be sure all members of the section process it in the same order.<br/>
  Once it reaches consensus, we are ready to process that candidate by letting them connect (see StartRelocatedNodeConnection) and then perform the resource_proof (see StartResourceProof).<br/>
  There are some subtleties, such as the fact that we only want to process one candidate at a time, but this is the general idea.
  </p>
  <button class="collapsible">RPC: ExpectCandidate</button>
  <div class="content">
    <p>We receive this RPC from a section that wants to relocate a node to our section.<br/>
    The node is not communicating with us yet, only once we sent RelocateResponse RPC to the originating section.<br/>
    On receiving it, we vote for ParsecExpectCandidate to process it in the same order as other members of our section.<br/>
    It kickstarts the entire chain of events in this diagram.<br/>
    Note that we could also see consensus on ParsecExpectCandidate before we ourselves voted for it in PARSEC, as long as enough members of our section did.
    </p>
  </div>
  <button class="collapsible">waiting_proofing_or_hop</button>
  <div class="content">
    <p>We want to accept at most one incoming relocation at a time into our section.<br/>
    The waiting_proofing_or_hop function returns the list of nodes that we have yet to resource proof or relocate through a new hop, (States from WaitingCandidateInfo until it reaches OnlineState  or RelocatedState).<br/>
    When the output of this function is not empty and we reach consensus on ParsecExpectCandidate, we send a RefuseCandidate RPC to the would-be-incoming-node so they can try another section or try again later.
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB

      Start["StartTopLevelDst:<br/>No exit - Needs killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> LoopStart
      LoopEnd --> LoopStart


      LoopStart --> WaitFor

      WaitFor((Wait for 1:))
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      RPC((RPC))
      RPC --ExpectCandidate--> VoteParsecExpectCandidate

      ParsecConsensus((Parsec<br/>consensus))
      ParsecConsensus --ParsecExpectCandidate--> Balanced

      VoteParsecExpectCandidate["vote_for(<br/>ParsecExpectCandidate)<br/>to handle the RPC consistently"]
      VoteParsecExpectCandidate --> LoopEnd

      Balanced(("Check?<br/>(shared state)"))
      Balanced -- "waiting_proofing_or_hop().contains(candidate)" --> SendIdenticalRelocateResponse
      Balanced -- "waiting_proofing_or_hop().is_empty()" --> SendRelocateResponse
      Balanced -- "Otherwise" --> SendRefuse

      SendIdenticalRelocateResponse["send_rpc(RelocateResponse)<br/>again to source section<br/>with original info"]
      SendIdenticalRelocateResponse --> LoopEnd

      SendRelocateResponse["add_node(NodeState=WaitingCandidateInfo)<br/><br/>send_rpc(RelocateResponse)<br/>to source section"]
      SendRelocateResponse --> LoopEnd

      SendRefuse["send_rpc(<br/>RefuseCandidate)<br/>to source section"]
      SendRefuse --> LoopEnd


  </div>

  <h2>Relocated node connection</h2>
  <div class=description>
  <p>Manage node with NodeState=WaitingConnectionInfo and connection info request/response RPCs.<br/>
    The candidate sends its CandidateInfo to the NaeManager of the target interval, so to ensure it reaches a section even in the event of a split or a merge.<br/>
    This target interval address could be the middle address of the interval, and the interval should cover a range that will not be split if the section splits.<br/>
    When we complete, we either stop responding to CandidateInfo RPCs if it failed, or we send NodeConnected RPC on success,<br/>
    (We could also omit this RPC, the node would continue sending CandidateInfo until ResourceProof RPC or time out).<br/>
    When the node reaches WaitingProofing state, the section becomes responsible for managing communication with this node as it would any of its adults.
  </p>
  <button class="collapsible">is_valid_waited_info</button>
  <div class="content">
    <p>Return true if
        <ul>
          <li> The given CandidateInfo is valid,
          <li> It matches one of our nodes that is in the WaitingCandidateInfo state,
          <li> The message_src (from the current RPC) is consistent with the CandidateInfo's new_public_id
        </ul>
    </p>
  </div>
  <button class="collapsible">is_valid_waited_connection</button>
  <div class="content">
    <p>Return true if the given message_src of the current RPC is a one of our nodes and is in WaitingConnectionInfo state.
    </p>
  </div>
  <button class="collapsible">shorter_prefix_section</button>
  <div class="content">
    <p>If we know of a section that has a shorter prefix than ours, we prefer for them to receive this incoming node rather than ourselves as it will help keep the Network's sections tree balanced.<br/>
    This shorter_prefix_section is a function that will return None if we are the shortest of any section we know, Some if there is a better candidate.<br/>
    If it is Some, we will relay the RPC to them instead of accepting the rellocation to our own section.
    </p>
  </div>
  <button class="collapsible">RelocatingState(Hop)</button>
  <div class="content">
    <p>A nodes state indicating that it is relocated without ageing further.<br/>
       Also returned as part of waiting_proofing_or_hop().
    </p>
  </div>
  <button class="collapsible">RelocatedNodeConnection_Reset</button>
  <div class="content">
    <p>Provides and external entry point to reset the currently processed nodes: Do not reject a node because it took longer than expected.<br/>
       This will be called for example after merge/split as the new nodes would become voters.
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB
      RelocatedNodeConnection["StartRelocatedNodeConnection"]
      style RelocatedNodeConnection fill:#f9f,stroke:#333,stroke-width:4px

      RelocatedNodeConnection --> StartCheckRelocatedNodeConnectionTimeout
      StartCheckRelocatedNodeConnectionTimeout["schedule(<br/>CheckRelocatedNodeConnectionTimeout)"]
      StartCheckRelocatedNodeConnectionTimeout --> LoopStart

      WaitFor(("Wait for 2:"))

      LoopStart-->WaitFor

      WaitFor -- Consensus--> ParsecConsensus
      ParsecConsensus((Consensus))

      ParsecConsensus -- "ParsecCheckRelocatedNodeConnection" --> CleanCandidates
      CleanCandidates["for candidate in both<br/>-waiting_node_connecting()<br/>-CANDIDATES:<br/><br/>purge_node_info(candidate)"]
      CleanCandidates --> ReStartCheckRelocatedNodeConnectionTimeout
      ReStartCheckRelocatedNodeConnectionTimeout["CANDIDATES=waiting_node_connecting()<br/><br/>schedule(<br/>CheckRelocatedNodeConnectionTimeout)"]
      ReStartCheckRelocatedNodeConnectionTimeout --> LoopEnd


      ParsecConsensus -- "ParsecCandidateInfo<br/>and<br/>is_valid_waited_info(<br/>CandidateInfo,<br/>message_src)" --> SetCandidateInfo
      SetCandidateInfo["update_node(<br/>CandidateInfo,<br/>NodeState=WaitingConnectionInfo)"]
      SetCandidateInfo --> LoopEnd

      ParsecConsensus -- "ParsecCandidateConnected<br/>and<br/>is_valid_waited_connection(<br/>message_src)" --> Balanced
      Balanced(("Check"))
      Balanced -- "shorter_prefix_section(<br/>).is_some()" --> RelocateToShorterPrefix
      RelocateToShorterPrefix["set_node_state(<br/>candidate,<br/>RelocatingState(Hop))"]
      RelocateToShorterPrefix --> SetConnected

      Balanced -- "Otherwise" --> SetWaitingProof
      SetWaitingProof["set_node_state(<br/>candidate,<br/>WaitingProofing)"]
      SetWaitingProof --> SetConnected

      SetConnected["send_rpc(<br/>NodeConnected)<br/><br/>(All communications now<br/>managed by elder like<br/>for other adults)"]
      SetConnected --> LoopEnd

      RPC((RPC))
      WaitFor --"RPC"--> RPC
      RPC -- "CandidateInfo" --> CheckCandidateInfo
      CheckCandidateInfo((Check))

      CheckCandidateInfo -- "Otherwise" --> DiscardRPC
      DiscardRPC[Discard RPC]
      DiscardRPC --> LoopEnd

      CheckCandidateInfo -- "is_valid_waited_info(<br/>CandidateInfo)" --> VoteForCandidateInfo
      VoteForCandidateInfo["vote_for(<br/>ParsecCandidateInfo)"]
      VoteForCandidateInfo --> LoopEnd

      CheckCandidateInfo -- "is_valid_waited_connection(<br/>message_src)" --> SendConnectionInfoRequest
      SendConnectionInfoRequest["send_rpc(<br/>ConnectionInfoRequest)"]
      SendConnectionInfoRequest --> LoopEnd

      RPC -- "ConnectionInfoResponse<br/>and<br/>is_valid_waited_connection(<br/>message_src)" --> ConnectCandidate
      ConnectCandidate["connect_to_candidate(<br/>ConnectionInfoResponse info)<br/><br/>vote_for(<br/>ParsecCandidateConnected)"]
      ConnectCandidate --> LoopEnd

      WaitFor --Event--> Event
      Event((Event))

      VoteParsecCheckRelocatedNodeConnection["vote_for(<br/>ParsecCheckRelocatedNodeConnection)"]
      Event -- CheckRelocatedNodeConnectionTimeout<br/>expire --> VoteParsecCheckRelocatedNodeConnection
      VoteParsecCheckRelocatedNodeConnection --> LoopEnd
      LoopEnd --> LoopStart

  </div>
  <div class="mermaid">
    graph TB

      Reset["RelocatedNodeConnection_Reset"]
      style Reset fill:#19f,stroke:#333,stroke-width:4px

      EndReset["End RelocatedNodeConnection_Reset"]
      style EndReset fill:#19f,stroke:#333,stroke-width:4px

      Reset --> ClearCandidates
      ClearCandidates["CANDIDATES.clear()<br/><br/>(Give time for new elder to catch up)"]
      ClearCandidates --> EndReset
  </div>

  <h2>Resource proof from a destination's point of view</h2>
  <div class=description>
  <p>In the previous diagram, we ensured an incoming candidate would only reach the "WaitingProofing" state once it was connected to our section and able to communicate with its elders. At this stage, the node would be a member of our peer_list.<br/>
  This is maintained accross merge/split as for any adult node, so we are ready to resource proof any node in WaitingProofing state<br/>
  <br/>
  This leads us here: to the resource proof.<br/>
  We only process up to one resource proof at a time (i.e: we wait for the current resource proof to reach completion before scheduling a new one).<br/>
  When we periodicaly decide to resource proof a node, we check if any node is ready for it:  WaitingProofing state, and pick the best candidate (There may be mutliple after a merge).<br/>
  As an elder, I will send the candidate a ResourceProof RPC. This gives them the "problem to solve". As they solve it, they will send me ResourceProofResponses. These will be parts of the proof. On receiving valid parts, I must send a ResourceProofReceipt. Once they finally send me the last valid part, they passed their resource proof and I vote for ParsecOnline (essentially accepting them as a member of my section).<br/>
  At any time during this process, they may timeout (The whole process it taking longer than expected), in which case I will decided to reject them and vote for ParsecPurgeCandidate.<br/>
  This process ends once I reach consensus on either accepting the candidate (ParsecOnline) or refusing them (ParsecPurgeCandidate).<br/>
  It is possible that both reach the quorum consensus, in which case the second one will be discarded in the flow above. It won't cause issues as consistency is the only property that matters here: if we accept someone who then went Offline, we will be able to detect they are Offline later with the standard Offline detection mechanism. But it is more likely that they took close to the time limit to complete their proof.
  </p>
  <button class="collapsible">CANDIDATE</button>
  <div class="content">
    <p>Option&lt(Candidate, Nonce)&gt.<br/>
	  The candidate we are currently ressource proofing, if any.<br/>
      The nonce is used to distinguish new attempts of resource proofing the same candidate after a merge or a split.
    </p>
  </div>
  <button class="collapsible">VOTED_ONLINE</button>
  <div class="content">
    <p>Once we've voted a node online, we don't care to handle further ResourceProofResponses from them.<br/>
    This local variable helps us with this.
    </p>
  </div>
  <button class="collapsible">RPC: ResourceProofResponse</button>
  <div class="content">
  <p>This RPC may continue to be sent by a node we have not accepted, even if consensus was reached to add it.<br/>
  It's OK to discard the RPC in this case as it is no longer relevant.
  </p>
  </div>
  <button class="collapsible">ParsecOnline<br/>ParsecPurgeCandidate</button>
  <div class=content>
    <p>The same node could be accepted by some nodes who would vote ParsecOnline, but also time out for some other nodes who would vote for ParsecPurgeCandidate.<br/>
    If it's the case, we only want to process the first of these two events and discard the other one.
    </p>
  </div>
  <button class="collapsible">ResourceProof_Cancel</button>
  <div class="content">
    <p>Provides an external entry point to cancel the currently processed nodes: Restart the resource proofing with all involved voters.<br/>
       This will be called for example after merge/split as the new nodes would become voters.
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB
      ResourceProof["StartResourceProof"]
      style ResourceProof fill:#f9f,stroke:#333,stroke-width:4px

      ResourceProof --> StartCheckResourceProofTimeout
      StartCheckResourceProofTimeout["schedule(<br/>CheckResourceProofTimeout)"]
      StartCheckResourceProofTimeout --> LoopStart

      WaitFor(("Wait for 2:"))

      LoopStart-->WaitFor

      WaitFor -- Consensus--> ParsecConsensus
      ParsecConsensus((Consensus))
      DiscardParsec["Discard<br/>Parsec<br/>event"]
      ParsecConsensus --ParsecOnline<br/>ParsecPurgeCandidate<br/>not for CANDIDATE--> DiscardParsec
      DiscardParsec --> LoopEnd

      ParsecConsensus -- ParsecPurgeCandidate<br/>for CANDIDATE --> RemoveNode
      ParsecConsensus -- ParsecOnline<br/>for CANDIDATE --> MakeOnline
      MakeOnline["set_node_state(<br/>Candidate,<br/>OnlineState)<br/><br/>send_rpc(<br/>NodeApproval)"]
      RemoveNode["purge_node_info(<br/>candidate node)"]
      RemoveNode --> ReStartCheckResourceProofTimeout
      MakeOnline --> ReStartCheckResourceProofTimeout

      ParsecConsensus -- "ParsecCheckResourceProof" --> SetCandidate
      SetCandidate["CANDIDATE=resource_proof_candidate()<br/><br/>(Best node with state=WaitingProofing)"]
      SetCandidate -->CheckRequestRP

      CheckRequestRP((Check))
      CheckRequestRP --"CANDIDATE.is_none()" --> ReStartCheckResourceProofTimeout
      ReStartCheckResourceProofTimeout["CANDIDATE=None<br/>VOTED_ONLINE==no<br/><br/>schedule(<br/>CheckResourceProofTimeout)"]
      ReStartCheckResourceProofTimeout --> LoopEnd

      CheckRequestRP --"CANDIDATE.is_some()"-->RequestRP
      RequestRP["send_rpc(<br/>ResourceProof)<br/>to CANDIDATE<br/><br/>schedule(TimeoutAccept)"]
      RequestRP --> LoopEnd


      RPC((RPC))
      WaitFor --RPC--> RPC
      RPC -- ResourceProofResponse<br/>from CANDIDATE<br/><br/>VOTED_ONLINE==no --> ProofResponse((Proof))
      ProofResponse((Check))
      SendProofReceit["send_rpc(<br/>ResourceProofReceipt)<br/>for proof"]
      ProofResponse -- Valid Part --> SendProofReceit
      VoteParsecOnline["vote_for(<br/>ParsecOnline)<br/><br/>VOTED_ONLINE=yes"]
      ProofResponse -- Valid End --> VoteParsecOnline


      DiscardRPC[Discard RPC]
      RPC -- ResourceProofResponse<br/>otherwise --> DiscardRPC
      DiscardRPC --> LoopEnd

      WaitFor --Event--> Event
      Event((Event))
      VoteParsecPurgeCandidate["vote_for(<br/>ParsecPurgeCandidate)"]
      Event -- TimeoutAccept<br/>expire --> VoteParsecPurgeCandidate

      VoteParsecCheckResourceProofTimeout["vote_for(ParsecCheckResourceProof)"]
      Event -- CheckResourceProofTimeout<br/>expire --> VoteParsecCheckResourceProofTimeout
      VoteParsecCheckResourceProofTimeout --> LoopEnd


      SendProofReceit-->LoopEnd
      VoteParsecOnline --> LoopEnd
      VoteParsecPurgeCandidate --> LoopEnd
      LoopEnd --> LoopStart

  </div>
  <div class="mermaid">
    graph TB

      Cancel["ResourceProof_Cancel"]
      style Cancel fill:#19f,stroke:#333,stroke-width:4px

      EndCancel["End ResourceProof_Cancel"]
      style EndCancel fill:#19f,stroke:#333,stroke-width:4px

      Cancel --> CancelCheckResourceProofTimeout
      CancelCheckResourceProofTimeout["CANDIDATE=None<br/>VOTED_ONLINE==no<br/><br/>schedule(<br/>CheckResourceProofTimeout)"]
      CancelCheckResourceProofTimeout --> EndCancel
  </div>

  <h1>Source section</h1>
  <div class=description>
  <p>As members of a section, each node must keep track of how many "work units" other nodes have performed.<br/>
      Once a node has accumulated enough work units to gain age, the section must work together to relocate that node to a new section where they can become 1 age unit older.<br/>
      These diagrams detail how this happens.
  </p>
  </div>
  <h2>Deciding that a member of our section should be relocated away</h2>
  <div class=description>
  <p>In these diagrams, we are modeling the simple version of node ageing that we decided to implement for Fleming:<br/>
  Work units are incremented for all nodes in the section every time a timeout reaches consenus. Because a quorum of elders must have voted for this timeout, the malicious nodes can't arbitrarily speed up the ageing of their nodes.<br/>
  Once a node has accumulated enough work units to be relocated, if no other node is currently relocating we set its state to RelocatingState(AgeIncrease). This node will then be actually relocated in StartRelocateSrc (see StartRelocateSrc).
  </p>
  <button class="collapsible">WorkUnitTimeout</button>
  <div class="content">
    <p>In the context of Fleming, nodes (especially adults) aren't doing meaningful work such as handling data.<br/>
    As a proxy, we use a time based metric to estimate how much work nodes have done (i.e: how long they remained Online and responsive).<br/>
    A local timeout wouldn't do here as it would allow malicious nodes to artificially age nodes in their sections faster. However, by reaching quorum on the fact a timeout happened, we ensure that at least one honest node has voted for the timeout.<br/>
    All nodes start the WorkUnitTimeout. On expiry, they vote for a WorkUnitIncrement in PARSEC and restart the timer.
    </p>
  </div>
  <button class="collapsible">increment_nodes_work_units</button>
  <div class="content">
    <p>This function increments the number of work units for all members of my peer_list (remember that n_work_units is a member of the PeerState struct).<br/>
    </p>
  </div>
  <button class="collapsible">nodes_relocating</button>
  <div class="content">
    <p>The collection of nodes currently relocating: With node state RelocatingState(AgeIncrease) only.<br/>
      It will most often be empty or have one element, unless a merge occurs in which case it may contain more than one element.
      Nodes coming back online, or needing an extra hop are not considered here.
    </p>
  </div>
  <button class="collapsible">get_node_to_relocate</button>
  <div class="content">
    <p>This function will return the best candidate for relocation, if any.<br/>
    First, it will only consider members of our peer_list that have the state: OnlineState<br/>
    We use the condition with nodes_relocating() to limit the number of OnlineState nodes to relocate to one (except possibly in case of a merge).<br/>
    It can return for instance the node with the largest number of work units for which the number of work units is greater than 2^age.
    </p>
  </div>
  <button class="collapsible">set_node_state</button>
  <div class="content">
    <p>This function mutates our peer_list to set the state (for example set RelocatingState(AgeIncrease) for the node).<br/>
    inputs:<br/>
    - node<br/>
    - state<br/>
    side-effect:<br/>
    - mutates peer_list
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB

      Start["StartTopLevelSrc:<br/>No exit - Needs killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> StartWorkUnitTimeOut

      StartWorkUnitTimeOut["schedule(WorkUnitTimeOut)"]
      StartWorkUnitTimeOut --> LoopStart
      LoopEnd --> LoopStart

      LoopStart --> WaitFor

      WaitFor((Wait for 3:))
      WaitFor --Event--> Event
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      Event((Event))
      Event -- WorkUnitTimeOut<br/>Trigger --> VoteParsecRelocationTrigger
      VoteParsecRelocationTrigger["vote_for(WorkUnitIncrement)<br/>schedule(WorkUnitTimeOut)"]
      VoteParsecRelocationTrigger --> LoopEnd

      ParsecConsensus((Parsec<br/>consensus))
      ParsecConsensus -- WorkUnitIncrement consensused --> IncrementWorkUnit
      IncrementWorkUnit["increment_nodes_work_units()"]
      IncrementWorkUnit-->AlreadyRelocating
      AlreadyRelocating(("Check?"))


      AlreadyRelocating --"nodes_relocating().is_empty()"--> SetRelocatingNodeState
      AlreadyRelocating --"Otherwise"--> LoopEnd

      SetRelocatingNodeState["set_node_state(get_node_to_relocate(), RelocatingState(AgeIncrease))"]
      SetRelocatingNodeState --> LoopEnd
  </div>

  <h2>Relocating a member of our section away from it</h2>
  <div class=description>
  <p>At this stage, we handle nodes that were marked for relocation.<br/>
  The process is quite simple: we send an ExpectCandidate RPC to the destination section. That section will either pass the node to a section with a shorter prefix, send us a RefuseCandidate RPC or eventually send us a RelocateResponse RPC. If the destination picked another section with a shorter prefix, that section will send us one of these RPCs (or suggest another section with a shorter prefix, but this recursion will end at some point).<br/>
  All in all, we have the certainty that eventually, exactly one of these two RPCs will make it to our section.<br/>
  When it does, it will be voted in PARSEC, regardless of the order of operations, so it will eventually make it through PARSEC.<br/>
  <br/>
  If a node in RelocatingState(AgeIncrease), is a non-elder adult node, we can try to relocate it. If they are an elder node, we will first wait for the Adult/Elder promotion/demotion flow to kick in and demote them to an adult. This will happen because we changed their state from OnlineState to RelocatingState, which means that they will get demoted.<br/>
  Nodes in RelocatingState(Hop) and then RelocatingState(BackOnline) are relocated after RelocatingState(AgeIncrease). Neither are full adults.
  <br/>
  If they refused our candidate, our job ends there: the candidate will simply be a candidate for relocation again later, so we will try to relocate it then.<br/>
  If they accepted the node and sent us a RelocateResponse RPC, so the ParsecRelocateResponse event reached consensus, we will send to the node that is being relocated the RelocatedInfo they will need.<br/>
  At this point, we will purge their information since this node isn't a member of our section anymore.
  <br/>
  Also of note: while we are preventing nodes with OnlineState from relocating when we are already relocating one of our Adult. We may still be actively relocating more than one node away from our section (for instance if two sections with a relocating node each merge).<br/>
  However, we will only handle one at a time per CheckRelocateTimeOut event.
  </p>
  <button class="collapsible">get_best_relocating_node_and_target</button>
  <div class="content">
    <p>Takes ALREADY_RELOCATING for the nodes it will ignore.<br/>
    Returns the best node to relocate and the target address to send it to<br/>
    There may be mutliple nodes relocating, for example because of a merge. Take the best one (oldest), and choose a target address.<br/>
    The target address is one managed by one of our neighbours. This could be random, or the current old_public_id with a single bit of the prefix flipped.<br/>
    This would help ensure that source and destination remain neighbours, even if the source splits.<br/>
    Using a target address instead of a section ensures we deliver the message even if the destination splits or merges.<br/>
    <br/>
    There are 3 states the node may be: RelocatingState(AgeIncrease), RelocatingState(Hop), and RelocatingState(BackOnline).<br/>
    Nodes will be selected in this order: RelocatingState(AgeIncrease), RelocatingState(Hop) and then RelocatingState(BackOnline).<br/>
    This ensures that we prioritize good node relocation.
    <br/>
    Note: It may be possible for a node to relocate to its sibling, and complete relocation after a merge occured.
    </p>
  </div>
  <button class="collapsible">ALREADY_RELOCATING</button>
  <div class="content">
    <p>The nodes we ignore when selecting a new node to send ExpectCandidate for.<br/>
       Local states are not carried over on merge or split, so we will resend ExpectCandidate earlier than we would otherwise.
    </p>
  </div>
  <button class="collapsible">is_our_relocating_node</button>
  <div class="content">
    <p>Is it a valid node that is not yet relocated (i.e State is RelocatingState(AgeIncrease), RelocatingState(Hop) or RelocatingState(BackOnline)).
    </p>
  </div>
  <button class="collapsible">RefuseCandidate/<br/>RelocateResponse</button>
  <div class="content">
    <p>Exactly one of these RPCs will be sent to us from the destination section as a response to our section's ExpectCandidate RPC.<br/>
    When this happens, we will immediately vote for it in PARSEC as we need to act in the same order as anyone else in our section.<br/>
    In case we re-sent the ExpectCandidate RPC, we may receive more than one RefuseCandidate and RelocateResponse. In this case we will pass on the first RelocateResponse to our Candidate.<br/>
    </p>
  </div>
  <button class="collapsible">RelocatedInfo</button>
  <div class="content">
    <p>Trigger relocation: Candidate will disconnect on receiving that RPC<br/>
    This RPC contains the RelocateResponse info, and the signatures prooving the source section received it and decided that particular response is the one to relocate to.<br/>
    In case we re-sent the ExpectCandidate RPC, we may receive more than one RefuseCandidate and RelocateResponse.<br/>
    In this case we must ensure that no single node could act on that other RelocateResponse and be accepted by the destination. this means the signatures must be provided only once the RelocateResponse is agreed.<br/>
    RelocatedInfo will contain the RelocateResponse info and the quorum of signatures gathered from PARSEC vote on ParsecRelocatedInfo.
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB
      Start["StartRelocateSrc:<br/>No exit - Needs killed"]
      style Start fill:#f9f,stroke:#333,stroke-width:4px
      Start --> StartCheckRelocateTimeOut

      StartCheckRelocateTimeOut["schedule(CheckRelocateTimeOut)"]
      StartCheckRelocateTimeOut --> LoopStart
      LoopEnd --> LoopStart

      LoopStart --> WaitFor

      WaitFor((Wait for 3:))
      WaitFor --Event--> Event
      WaitFor --RPC--> RPC
      WaitFor --Parsec<br/>consensus--> ParsecConsensus

      Event((Event))
      Event -- CheckRelocateTimeOut<br/>Trigger --> VoteParsecCheckRelocate
      VoteParsecCheckRelocate["vote_for(<br/>ParsecCheckRelocate)<br/>schedule(<br/>CheckRelocateTimeOut)"]
      VoteParsecCheckRelocate --> LoopEnd

      RPC((RPC))
      RPC --RefuseCandidate--> VoteParsecRefuseCandidate
      RPC --RelocateResponse--> VoteParsecRelocateResponse
      VoteParsecRefuseCandidate["vote_for(<br/>ParsecRefuseCandidate)"]
      VoteParsecRefuseCandidate --> LoopEnd
      VoteParsecRelocateResponse["vote_for(<br/>ParsecRelocateResponse)"]
      VoteParsecRelocateResponse --> LoopEnd

      ParsecConsensus((Parsec<br/>consensus))
      ParsecConsensus -- ParsecCheckRelocate<br/>consensused --> CheckNeedRelocate
      CheckNeedRelocate((Check?))
      CheckNeedRelocate--"Otherwise" -->CheckNeedResend

      CheckNeedRelocate--"get_best_relocating_node_and_target(<br/>ALREADY_RELOCATING).is_some()" --> SendExpectCandidate
      SendExpectCandidate["(node, target)=<br/>get_best_relocating_node_and_target(<br/>ALREADY_RELOCATING)<br/><br/>send_rpc(<br/>ExpectCandidate(node))<br/>to target NaeManager<br/><br/>ALREADY_RELOCATING<br/>.insert(node)"]
      SendExpectCandidate --> CheckNeedResend

      CheckNeedResend((Check?))
      CheckNeedResend -- Otherwise --> DecResendCount
      DecResendCount["RESEND_TRIGGER--"]
      DecResendCount --> LoopEnd

      CheckNeedResend -- "RESEND_TRIGGER==0<br/>or<br/>ALREADY_RELOCATING.is_empty()" --> AllowResendCandidates
      AllowResendCandidates["ALREADY_RELOCATING.clear()<br/>RESEND_TRIGGER=3"]
      AllowResendCandidates --> LoopEnd


      ParsecConsensus --"ParsecRefuseCandidate<br/>and<br/>is_our_relocating_node(node)"--> RefusedCandidate
      RefusedCandidate["ALREADY_RELOCATING<br/>.remove(node)"]
      RefusedCandidate --> LoopEnd

      ParsecConsensus --"ParsecRelocateResponse<br/>and<br/>is_our_relocating_node(node)"--> VoteProvableRelocateInfo
      VoteProvableRelocateInfo["set_node_state(<br/>node,<br/>RelocatedState(RelocateResponse Info)<br/>(Vote for same relocation if merge/split<br/>so only one valid proof exists)<br/><br/>vote_for(<br/>ParsecRelocatedInfo(RelocateResponse Info))"]
      VoteProvableRelocateInfo --> LoopEnd

      ParsecConsensus --"ParsecRefuseCandidate/<br/>ParsecRelocateResponse<br/>otherwise"--> DiscardVote
      DiscardVote[Discard<br/>Vote]
      DiscardVote --> LoopEnd

      ParsecConsensus --"ParsecRelocatedInfo"--> SendProvableRelocateInfo
      SendProvableRelocateInfo["send_rpc(RelocatedInfo)<br/>to node<br/><br/>ParsecRelocatedInfo proofs for CandidateInfo<br/>Node may be already gone"]
      SendProvableRelocateInfo-->PurgeNodeInfos
      PurgeNodeInfos["purge_node_info(<br/>node)"]
      PurgeNodeInfos--> LoopEnd
  </div>

  <h1>Elder-only</h1>
  <h2>Process for Adult/Elder promotion and demotion including merge</h2>
  <div class=description>
  <p>This flow updates the elder status of our section nodes if needed.<br/>
     Because it is interlinked, it also handles merging section: When merging, no elder change can happen.<br/>
     However other flows continue, so relocating to and from the section is uninterupted:<br/>
     We have to be careful that the section follows up on relocation once merged, so we may want to avoid active relocation when merging.
  </p>

  <button class="collapsible">CheckElderTimeout</button>
  <div class="content">
    <p>As for incrementing work units, we want to update the eldership status of all nodes in a section on a syncrhonised, regular basis.<br/>
    For this reason, it makes sense to have a timer going through Parsec.<br/>
    Note that this timer has to be only as fast as needed so that it remains highly unlikely that 1/3 of the elders in any section would go offline within one timer's duration.
    </p>
  </div>
  <button class="collapsible">Merge RPC</button>
  <div class="content">
    <p>A section sends a Merge RPC to their neighbour section when they are ready to merge at the given SectionInfo digest.<br/>
    In this flow, we handle both situations:<br>
    <ul>
      <li> Our neighbour triggers the merge and we receive their Merge RPC.<br>
           We then vote for ParsecNeighbourMerge.
      <li> We trigger the merge ourselves (see ProcessMerge flow)
    </ul>
    </p>
  </div>
  <button class="collapsible">ParsecNeighbourMerge</button>
  <div class="content">
    <p>We vote for this Parsec event on receiving a Merge RPC from our neighbour section.<br>
    It contains the information about them that we need for merging. When this PARSEC event reaches consensus in PARSEC, we store that information by calling store_merge_infos.
    </p>
  </div>
  <button class="collapsible">store_merge_infos</button>
  <div class="content">
    <p>This function is used to store the merge information from a neighbour section locally.<br>
    Once it has been stored, has_merge_infos will return true and we will be ready to enter the ProcessMerge flow.
    </p>
  </div>
  <button class="collapsible">has_merge_infos</button>
  <div class="content">
    <p>This function indicates that we received sufficient information from our neighbour section needing a merge, and reached consensus on it.<br>
    We are ready to start the merging process with them.
    </p>
  </div>
  <button class="collapsible">merge_needed</button>
  <div class="content">
    <p>This function indicates that we need merging (as opposed to a merge triggered by our neighbour's needs).<br>
    The details for the trigger are still in slight flux, but here are some possibilities:
    <ul>
      <li> The number of Online adults plus elders is below our min section size of 10 elder plus 90 Adults
      <li> A certain proportion of the adults in this section are marked Offline
    </ul>
    </p>
  </div>
  <button class="collapsible">check_elder_change</button>
  <div class="content">
    <p>If any of our elders is not Online, they must be demoted to a plain old adult.<br/>
    If this happens, the oldest adult must be promoted to the elder state as a replacement.<br/>
    Alternatively, if any of our Online adult nodes is older than any of our elders, the youngest elder must be demoted and this adult must be promoted.<br/>
    Note that elder changes are only processed when the section is not in the middle of handling a merge.
    </p>
  </div>
  </div>
  <button class="collapsible">split_needed</button>
  <div class="content">
    <p>This function indicates that we need splitting.<br>
    The details for the trigger are still in slight flux, but here are some possibilities:
    <ul>
      <li> The number of Online adults plus elders is above our min section size of 10 elder plus 90 Adults + buffer
    </ul>
    </p>
  </div>
  <div class="mermaid">
      graph TB
      CheckAndProcessElderChange["StartCheckAndProcessElderMergeChange:<br/>No exit - Needs killed"]
      style CheckAndProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px

      CheckAndProcessElderChange -->  StartCheckElderTimeout
      StartCheckElderTimeout["schedule(<br/>CheckElderTimeout)"]
      StartCheckElderTimeout -->  LoopStart


      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      WaitFor -- Event --> Event
      Event((Event))
      Event-- CheckElder<br/>Timeout--> VoteCheckElderTimeout
      VoteCheckElderTimeout["vote_for(<br/>ParsecCheckElderTimeout)"]
      VoteCheckElderTimeout--> LoopEnd

      RPC((RPC))
      WaitFor -- RPC --> RPC
      RPC --Merge--> VoteParsecNeighbourMerge
      VoteParsecNeighbourMerge["vote_for(<br/>ParsecNeighbourMerge)"]
      VoteParsecNeighbourMerge --> LoopEnd

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus

      Consensus -- "ParsecNeighbourMerge" --> SetNeighbourMerge
      SetNeighbourMerge["store_merge_infos(ParsecNeighbourMerge info)"]
      SetNeighbourMerge-->LoopEnd

      Consensus--"ParsecCheckElderTimeout"-->CheckMergeNeeded
      CheckMergeNeeded(("Check"))

      CheckMergeNeeded--"Otherwise"-->CheckElderChange
      CheckElderChange(("Check"))

      CheckElderChange -- "Otherwise" --> CheckNeedSplit

      CheckNeedSplit(("Check"))
      CheckNeedSplit --"Otherwise" --> RestartTimeout
      RestartTimeout["schedule(<br/>CheckElderTimeout)"]
      RestartTimeout-->LoopEnd

      CheckNeedSplit --"split_needed()" --> Concurrent2
      Concurrent2{"Concurrent<br/>paths"}
      Concurrent2 --> ProcessSplit
      Concurrent2 --> LoopEnd

      ProcessSplit["ProcessSplit"]
      style ProcessSplit fill:#f9f,stroke:#333,stroke-width:4px
      ProcessSplit --> CancelResourceProof

      CheckElderChange --"check_elder_change()<br/><br/>Has elder changes: elder first ordered by:<br/>State=Online then age then name."--> Concurrent0
      Concurrent0{"Concurrent<br/>paths"}
      Concurrent0 --> ProcessElderChange
      Concurrent0 --> LoopEnd

      ProcessElderChange["ProcessElderChange(changes)"]
      style ProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px
      ProcessElderChange -->CancelResourceProof


      ResetRelocatedNodeConnection["ResourceProof_Cancel"]
      style CancelResourceProof fill:#19f,stroke:#333,stroke-width:4px
      CancelResourceProof --> ResetRelocatedNodeConnection

      ResetRelocatedNodeConnection["RelocatedNodeConnection_Reset"]
      style ResetRelocatedNodeConnection fill:#19f,stroke:#333,stroke-width:4px
      ResetRelocatedNodeConnection --> RestartTimeout

      CheckMergeNeeded --"merge_needed()<br/>or<br/>has_merge_infos()"-->Concurrent1
      Concurrent1{"Concurrent<br/>paths"}
      Concurrent1 --> ProcessMerge
      Concurrent1 --> LoopEnd

      ProcessMerge["ProcessMerge"]
      style ProcessMerge fill:#f9f,stroke:#333,stroke-width:4px
      ProcessMerge --> CancelResourceProof

      LoopEnd --> LoopStart
  </div>

  <h2>Process Adult/Elder promotion and demotion needed from last check</h2>
  <div class=description>
  <p>Vote for Add for new elders, Remove for no longer elders and NewSectionInfo<br/>
     This handles any change, it does not care whether one or all elders are changed, this is decided by the calling function.
 </p>
  <button class="collapsible">WAITED_VOTES</button>
  <div class="content">
    <p>At any time, there must be exactly NUM_ELDERS (say 10) elders per section.<br>
    To maintain this invariant, we must handle multiple eldership changes atomically<br>
    We accomplish this by voting for all the membership changes needed at once and waiting for all these votes to reach consensus before reflecting the status change in our chain.<br>
    </p>
  </div>
  <button class="collapsible">new_section_info</button>
  <div class="content">
    <p>A list of PublicId.<br>
    The content of the NewSectionInfo parsec event that reached consensus.
    </p>
  </div>
  <button class="collapsible">update_elder_status</button>
  <div class="content">
    <p>This function updates the eldership status of each node in the chain based on the new section info: the nodes with their public id in new_section_info are the exact set of current elders.<br>
    Input:
    <ul>
      <li>new_section_info: Set&ltPublicId&gt<br>
      The new section info that just reached consensus.
    </ul>
    Side-effect:
    <ul>
      <li>Mutates the chain.
    </ul>
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB
      ProcessElderChange["ProcessElderChange<br/>(Take elder changes)<br/>(shared state)"]
      style ProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px

      EndRoutine["End of ProcessElderChange<br/>(shared state)"]
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      ProcessElderChange -->  MarkAndVoteSwapNewElder
      MarkAndVoteSwapNewElder["vote_for(Add) for new elders<br/>vote_for(Remove) for now adults nodes<br/>vote_for(NewSectionInfo)<br/><br/>WAITED_VOTES.insert(all votes)"]
      MarkAndVoteSwapNewElder --> LoopStart

      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus

      Consensus -- "WAITED_VOTES.contains(vote)" --> OneVoteConsensused
      OneVoteConsensused["WAITED_VOTES.remove(vote)"]

      OneVoteConsensused --> WaitComplete
      WaitComplete(("Check?"))
      WaitComplete--"WAITED_VOTES<br/>.is_empty()<br/>(Wait complete)"-->MarkNewElderAdults
      MarkNewElderAdults["update_elder_status(new_section_info)"]
      MarkNewElderAdults--> EndRoutine
      WaitComplete--"!WAITED_VOTES<br/>.is_empty()<br/>(Wait not complete)"--> LoopEnd

      LoopEnd --> LoopStart
  </div>

  <h2>Handling merges</h2>
  <div class=description>
  <p>Send Merge RPC, and take over handling any ParsecNeighbourMerge.<br/>
     Complete when one merge has completed, and a NewSectionInfo is consensused.<br/>
     If multi-stage merges are required, they will require calling this function again<br/>
     While in this sanctuary, our SectionInfo shall not be disturbed by elder changes.
     This stops us from changing our SectionInfo after indicating to our neighbour the last SectionInfo before merge.
  </p>
  <button class="collapsible">Merge RPC</button>
  <div class="content">
    <p>We send it to our sibling section (or sections with longer prefix) on entering ProcessMerge.<br>
    We send Merge irrespective of whether we are the section that triggered the merge. This allows all sections involved in the merge to receive a Merge RPC, which is how ParsecNeighbourMerge gets voted for.
    </p>
  </div>
  <button class="collapsible">ParsecNeighbourMerge</button>
  <div class="content">
    <p>This PARSEC event indicates that our neighbour section is ready to merge with us.<br>
    It is voted for in the StartCheckAndProcessElderMergeChange flow, on receipt of a Merge RPC.<br>
    It contains their SectionInfo (or digest for it).<br>
    </p>
  </div>
  <button class="collapsible">store_merge_infos</button>
  <div class="content">
    <p>Store the neighbour's merge info, may not be sibling in case of multi merge<br/>
    </p>
  </div>
  <button class="collapsible">has_sibling_merge_info</button>
  <div class="content">
    <p>Did we store the neighbour's merge info for our sibling<br/>
    </p>
  </div>
  <button class="collapsible">merge_sibling_info_to_new_section</button>
  <div class="content">
    <p>Remove the stored sibling's merge info and return the NewSectionInfo.<br/>
    </p>
  </div>
  <button class="collapsible">NewSectionInfo</button>
  <div class="content">
    <p>Once we are ready to merge, have received our neighbour's SectionInfo through their Merge RPC, and subsequently reached consensus on the ParsecNeighbourInfo we voted for, we have all the information needed to decide on the membership of our post-merge section.<br>
    This is the NewSectionInfo.
    </p>
  </div>
  <button class="collapsible">complete_merge</button>
  <div class="content">
    <p>With the NewSectionInfo in hands, completing the merge process consists on joining the newly formed section and leaving the old one behind.
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB
      ProcessMerge["ProcessMerge<br/>(shared state)"]
      EndRoutine["End of ProcessMerge<br/>(shared state)"]
      style ProcessMerge fill:#f9f,stroke:#333,stroke-width:4px
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      ProcessMerge -->  SendMergeRpc
      SendMergeRpc["send_rpc(Merge)"]
      SendMergeRpc --> LoopStart

      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus
      Consensus -- "NewSectionInfo" --> CompleteMerge
      CompleteMerge["complete_merge()<br/>(Start parsec with new genesis...)"]
      CompleteMerge --> MarkNewElderAdults

      MarkNewElderAdults["update_elder_status(new_section_info)"]
      MarkNewElderAdults--> EndRoutine

      Consensus -- "ParsecNeighbourMerge" --> SetNeighbourMerge
      SetNeighbourMerge["store_merge_infos(ParsecNeighbourMerge info)"]
      SetNeighbourMerge --> CheckMerge

      CheckMerge((Check))
      CheckMerge -- "has_sibling_merge_info()" --> VotForNewSectionInfo
      VotForNewSectionInfo["merge_sibling_info_to_new_section()<br/>vote_for(NewSectionInfo)"]
      VotForNewSectionInfo--> LoopEnd

      CheckMerge -- "Otherwise" --> LoopEnd

      LoopEnd --> LoopStart
  </div>

  <h2>Handling splits</h2>
  <div class=description>
  <p>Vote for the two NewSectionInfo to gather required signatures<br/>
 </p>
  <button class="collapsible">WAITED_VOTES</button>
  <div class="content">
    <p>Wait for all these votes to reach consensus before reflecting the status change in our chain.<br>
      Both sections need to be consensused before we move on so we do not leave one behind with not enough voters.
    </p>
  </div>
  <button class="collapsible">complete_split</button>
  <div class="content">
    <p>With the NewSectionInfo in hands, completing the split process consists on joining the correct newly formed section and leaving the old one behind.
    </p>
  </div>
  <button class="collapsible">new_section_info</button>
  <div class="content">
    <p>A list of PublicId.<br>
    The content of the NewSectionInfo parsec event that reached consensus that we are now a member of.
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB
      ProcessElderChange["ProcessElderChange<br/>(Take elder changes)<br/>(shared state)"]
      style ProcessElderChange fill:#f9f,stroke:#333,stroke-width:4px

      EndRoutine["End of ProcessElderChange<br/>(shared state)"]
      style EndRoutine fill:#f9f,stroke:#333,stroke-width:4px

      ProcessElderChange -->  VoteNewSections
      VoteNewSections["vote_for(NewSectionInfo) for the two new sections<br/><br/>WAITED_VOTES.insert(all votes)"]
      VoteNewSections --> LoopStart

      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus

      Consensus -- "WAITED_VOTES.contains(vote)" --> OneVoteConsensused
      OneVoteConsensused["WAITED_VOTES.remove(vote)"]

      OneVoteConsensused --> WaitComplete
      WaitComplete(("Check?"))
      WaitComplete--"WAITED_VOTES<br/>.is_empty()<br/>(Wait complete)"-->CompleteSplit
      CompleteSplit["complete_split()<br/>(Start parsec with new genesis...)"]
      CompleteSplit --> MarkNewElderAdults

      MarkNewElderAdults["update_elder_status(new_section_info)"]
      MarkNewElderAdults--> EndRoutine

      WaitComplete--"!WAITED_VOTES<br/>.is_empty()<br/>(Wait not complete)"--> LoopEnd
      LoopEnd --> LoopStart
  </div>

  <h2>Handling members of our section going Online or Offline</h2>
  <div class=description>
  <button class="collapsible">RelocatingState(BackOnline)</button>
  <div class="content">
    <p>A nodes state indicating that it is relocated with age reduced as it went offline.<br/>
    </p>
  </div>
  </div>
  <div class="mermaid">
      graph TB
      CheckOnlineOffline["CheckOnlineOffline:<br/>No exit - Needs killed"]
      style CheckOnlineOffline fill:#f9f,stroke:#333,stroke-width:4px

      CheckOnlineOffline -->  LoopStart

      WaitFor(("Wait for 5:"))
      LoopStart --> WaitFor

      LocalEvent((Local<br/>Event))
      WaitFor --event--> LocalEvent

      LocalEvent -- Node detected offline --> VoteNodeOffline
      VoteNodeOffline["vote_for(<br/>ParsecOffline)"]
      VoteNodeOffline --> LoopEnd

      LocalEvent -- Node detected back online --> VoteNodeBackOnline
      VoteNodeBackOnline["vote_for(<br/>ParsecBackOnline)"]
      VoteNodeBackOnline --> LoopEnd

      Consensus((Consensus))
      WaitFor-- Parsec<br/>consensus --> Consensus
      Consensus--"ParsecOffline"-->SetOfflineState
      SetOfflineState["set_node_state(<br/>node,<br/>OfflineState)"]
      SetOfflineState -->LoopEnd

      Consensus -- "ParsecBackOnline" --> SetRelocating
      SetRelocating["set_node_state(<br/>node,<br/>RelocatingState(BackOnline))"]

      SetRelocating --> LoopEnd
      LoopEnd --> LoopStart
  </div>

  <h1>Node relocation overview</h1>

  <h2>Successfully relocate a node from source to destination section</h2>
  <div class=description>
  <button class="collapsible">ExpectCandidate</button>
  <div class="content">
    <p>Sent by the source section when a candidate needs to relocate<br/>
    Contains:<br/>
      <ul>
        <li>old_public_id: PublicId - The joining node's current public ID.<br>
        <li>new_age: u8 - The joining node's new public id age. <br>
            Decided by source section, could be +1 or /2 depending on why we relocate.<br>
            (If we want to allow early relocate, we could also add carried over work units.)
      </ul>
    </p>
  </div>
  <button class="collapsible">RelocateResponse</button>
  <div class="content">
    <p>Sent by destination section when a candidate is accepted<br/>
    Contains:<br/>
      <ul>
        <li>target_interval: (XorName, XorName) - The interval into which the joining node should join.<br>
        <li>section_info: SectionInfo - The destination section that the joining node will trust.<br>
      </ul>
    </p>
  </div>
  <button class="collapsible">RefuseCandidate</button>
  <div class="content">
    <p>Sent by destination section when a candidate is refused<br/>
      Contains: Empty
    </p>
  </div>
  <button class="collapsible">RelocatedInfo</button>
  <div class="content">
    <p>Sent by source section when a candidate is relocated to the relocated node<br/>
      Contains:<br/>
      <ul>
        <li>target_interval: (XorName, XorName) - The interval into which the joining node should join.<br>
        <li>section_info: SectionInfo - The destination section that the joining node will trust.<br>
        <li>proof: Signatures - Quorum of signature for the candidate to prove the source section relocated it with these infos.<br>
      </ul>
    </p>
  </div>
  <button class="collapsible">CandidateInfo</button>
  <div class="content">
    <p>Sent by the joining node to the target interval's NaeManager to initiate the joining process<br/>
      Contains:<br/>
      <ul>
        <li>old_public_id: PublicId - PublicId from before relocation.<br>
        <li>new_public_id: PublicId - PublicId from after relocation.<br>
        <li>signature_using_old: Signature - Signature of concatenated PublicIds using the pre-relocation key.<br>
        <li>signature_using_new: Signature - Signature of concatenated PublicIds and signature_using_old using the post-relocation key.<br>
        <li>new_client_auth: Authority - Client authority from after relocation.<br>
        <li>source_proof: Signatures - Quorum of signature from the source section proving the source approved that relocation.<br>
            This will be checked against the stored information in the candidate node state.<br/>
      </ul>
    </p>
  </div>
  <button class="collapsible">ConnectionInfoRequest/ConnectionInfoResponse</button>
  <div class="content">
    <p>Sent to collect information needed to establish a direct connection: Unchanged
      </p>
  </div>
  <button class="collapsible">NodeConnected</button>
  <div class="content">
    <p>Sent by the destination section to the joining node when connected<br/>
      Contains:<br/>
      <ul>
        <li>section_info_proofs: Vec&lt(SectionInfo, ProofSet)&gt - Signed section infos with root starting with the stored SectionInfo in the candidate node state.<br>
        <li>current_info: GenesisPfxInfo - All the info needed when this node becomes an adult or elder.<br>
      </ul>
    </p>
  </div>
  <button class="collapsible">ResourceProof/ResourceProofResponse/ResourceProofReceipt</button>
  <div class="content">
    <p>Sent to process resource proof: Unchanged<br/>
      (Could avoid some malicious behaviour with nonce/counter/proofs that we started resource proof).
    </p>
  </div>
  <button class="collapsible">NodeApproval</button>
  <div class="content">
    <p>Sent by destination section when a candidate becomes an adult / resource proof is completed.<br/>
      Contains: Empty (Any information needed by an adult/elder should be sent to all connected members, and updated as it changes)
    </p>
  </div>
  </div>
  <div class="mermaid">
    sequenceDiagram
    participant Src as Source Section
    participant Node as Relocating Node
    participant Dst as Destination Section


    loop FindDestination
      Src->>+Dst: Routing RPC: ExpectCandidate
      opt Refuse
        Dst-->>Src: Routing RPC: RefuseCandidate
      end
    end
    Dst-->>-Src: Routing RPC: RelocateResponse
    Src->>Node: Direct node-to-node RPC: RelocatedInfo

    loop NodeConnection
      Node->>Dst: Proxied Routing RPC to group: CandidateInfo
      Dst->>+Node: Proxied Routing RPC: ConnectionInfoRequest
      Node-->>-Dst: Proxied Routing RPC: ConnectionInfoResponse
    end
    Dst->>Node: Unproxied Group RPC: NodeConnected

    Dst->>Node: Direct node-to-node RPC: ResourceProof
    loop ResProof
      Node->>+Dst: Direct node-to-node RPC: ResourceProofResponse
      Dst-->>-Node: Direct node-to-node RPC: ResourceProofReceipt
    end

    Dst->>Node: Unproxied Group RPC: NodeApproval
  </div>

  <script src="mermaid.min.js"></script>
  <script>mermaid.initialize({sequence: { width: 400, actorMargin: 100, boxTextMargin: 50, messageMargin: 50 }, startOnLoad:true});</script>
  <script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>
</body>
</html>
